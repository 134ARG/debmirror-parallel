#!/usr/bin/perl
#
# Debian partial mirror script, with ftp and package pool support.
# Copyright 2001 Joey Hess <joeyh@debian.org>, GPL'd.

# TODO: remove all empty directories.
# TODO: my symlink farm thing.
# TODO: non-us!

#######################################################################################
# Configure this program here:

# The system to mirror from.
my $hostname="ftp.kernel.org";
# Root of the remote debian mirror.
my $remoteroot="/debian";
# WHere to put the local mirror.
my $localroot="/mirror/debian";
# List of distributions to mirror.
my @dists=qw{unstable};
# List of sections to mirror.
my @sections=qw{main contrib non-free};
# List of architectures to mirror (include binary- prefix)
my @arches=qw{binary-i386 debian-installer/binary-i386};
# List of sources to mirror (generally either ('source') or empty.
my @sources=qw{source};
# Should I do slow, paranoid md5 checks to catch files that are of same size as
# what is listed in Packages/Sources files, but do not md5sum the same.
my $check_md5sums=0;

#######################################################################################

use warnings;
use strict;
use Net::FTP;
use Getopt::Long;

# Parse command line.
my ($debug, $progress);
GetOptions(
	'debug|d' => \$debug,
	'progress|p' => \$progress,
) or die "Syntax: $0 [-d|-p]\n";

# Set up mirror directory.
make_dir($localroot);
chdir($localroot) or die "chdir $localroot: $!";

# Start up ftp.
my $ftp;
if ($progress) {
	$ftp=Net::FTP->new($hostname, Debug => $debug, Hash => *STDOUT);
}
else {
	$ftp=Net::FTP->new($hostname, Debug => $debug);
}
$ftp->login; # anonymous
$ftp->binary;

# This hash holds all the files we know about, If the hash key is false,
# the file already exists in the mirror and does not need to be downloaded,
# if it is true the file needs to be downloaded. Filenames should be
# relative to $localroot.
my %files;

# Get Packages and Sources files and other miscellany.
my (@package_files, @source_files);
foreach my $dist (@dists) {
	foreach my $section (@sections) {
		foreach my $arch (@arches) {
			my $subdir="dists/$dist/$section/$arch";
			$ftp->cwd("$remoteroot/$subdir") or
				warn "skipping $remoteroot/$subdir\n" and next;
			make_dir($subdir);
			ftp_get("Packages.gz", "$subdir/Packages.gz") and
				push @package_files, "$subdir/Packages.gz";
			$files{"$subdir/Packages.gz"}=0;
			# Get the release file later.
			$files{"$subdir/Release"}=1;
		}
		foreach my $source (@sources) {
			my $subdir="dists/$dist/$section/$source";
			$ftp->cwd("$remoteroot/$subdir") or
				warn "skipping $remoteroot/$subdir\n" and next;
			make_dir($subdir);
			ftp_get("Sources.gz", "$subdir/Sources.gz") and
				push @source_files, "$subdir/Sources.gz";
			$files{"$subdir/Sources.gz"}=0;
		}
	}
}

# Parse Packages and Sources files and add to the file list everything therein.
$/="\n\n";
my ($filename, $size, $md5sum, $md5, $directory);
if ($check_md5sums) {
        eval q{use Digest::MD5};
	$md5=Digest::MD5->new;
}
foreach my $file (@package_files) {
	open IN, "zcat $file|" or die "$file: $!";
	while (<IN>) {
		($filename)=m/^Filename:\s+(.*)/im;
		($size)=m/^Size:\s+(\d+)/im;
		($md5sum)=m/^MD5sum:\s+([A-Za-z0-9]+)/im;
		$files{$filename}=check_file($filename, $size, $md5sum);
	}
	close IN;
}
foreach my $file (@source_files) {
	open IN, "zcat $file|" or die "$file: $!";
	while (<IN>) {
		($directory) = m/^Directory:\s+(.*)/im;
		while (m/^ ([A-Za-z0-9]{32} .*)/mg) {
			($md5sum, $size, $filename)=split(' ', $1, 3);
			$filename="$directory/$filename";
			$files{$filename}=check_file($filename, $size, $md5sum);
		}
	}
	close IN;
}

# Download all files that we need to get.
$ftp->cwd($remoteroot) or die "cdw to $remoteroot failed";
my $dirname;
foreach my $file (sort keys %files) {
	if ($files{$file}) {
		($dirname) = $file =~ m:(.*)/:;
		make_dir($dirname);
		ftp_get($file, $file);
	}
	else {
		print "skipping $file\n" if $debug;
	}
}

$ftp->quit;

# Now clean up the mirror. First, remove all files in the mirror that
# we don't know about.
$/="\n";
foreach my $file (`find . -type f`) {
	chomp $file;
	$file=~s:^\./::;
	unless (exists $files{$file}) {
		print "deleting $file\n" if $debug;
		unlink $file or die "unlink $file: $!";
	}
}
# Then remove all empty directories.
system("find . -type d -empty | xargs -r rmdir -p --ignore-fail-on-non-empty");

# Pass this function a filename, a file size (bytes), and a md5sum (hex).
# It will return true if the file nees to be downloaded.
sub check_file {
	my ($filename, $size, $md5sum)=@_;
	if (-f $filename and $size == -s _) {
		if ($check_md5sums) {
			open HANDLE, $filename or
				die "$filename: $!";
			$md5->addfile(*HANDLE);
			if ($md5sum eq $md5->hexdigest) {
				return 0;
			}
		}
		else {
			# Assume it is ok, w/o md5 check.
			return 0;
		}
	}

	return 1;
}

# Get a file via ftp, first displaying its filename if progress is on.
# I should just be able to subclass Net::Ftp and override the get method,
# but it's late.
sub ftp_get {
	print "$_[0]: " if $progress;
	my $ret=$ftp->get(@_);
	print "failed\n" if ! $ret;
	return $ret;
}

# Make a directory including all needed parents.
{
	my %seen;
	
	sub make_dir {
		my $dir=shift;
		
		my @parts=split('/', $dir);
		my $current='';
		foreach my $part (@parts) {
			$current.="$part/";
			if (! $seen{$current}) {
				mkdir $current;
				$seen{$current}=1;
			}
		}
	}
}
